From ca24da011b79f33bc7f4198aa5fc2c5555ffc8a7 Mon Sep 17 00:00:00 2001
From: Sudhakar Krishnan <sudhakar25@gmail.com>
Date: Sat, 23 Jan 2016 11:37:50 -0800
Subject: [PATCH] MTP Uevent for connect disconnect

---
 drivers/usb/gadget/Kconfig    |   9 ++
 drivers/usb/gadget/configfs.c | 199 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 205 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 65d110d..b0fbc5c 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -464,6 +464,15 @@ config USB_CONFIGFS_F_MTP
 	  the file level. Thus exposing the relevant content but hiding
 	  the system/restricted files.
 
+config USB_CONFIGFS_UEVENT
+	bool "Uevent notification of Gadget state"
+	depends on USB_CONFIGFS
+	help
+	Enable uevent notifications to userspace when the gadget
+	state changes. The gadget can be in any of the following
+	three states: "CONNECTED/DISCONNECTED/CONFIGURED"
+
+
 source "drivers/usb/gadget/legacy/Kconfig"
 
 endchoice
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index 0495c94..17c024c 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -9,6 +9,15 @@
 #include "u_f.h"
 #include "u_os_desc.h"
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+#include <linux/platform_device.h>
+#include <linux/kdev_t.h>
+#include <linux/usb/ch9.h>
+
+static struct class *usb_gadget_class;
+static struct device *usb_gadget_device;
+#endif
+
 int check_user_usb_string(const char *name,
 		struct usb_gadget_strings *stringtab_dev)
 {
@@ -63,6 +72,14 @@ struct gadget_info {
 	bool use_os_desc;
 	char b_vendor_code;
 	char qw_sign[OS_STRING_QW_SIGN_LEN];
+
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	struct device *dev;
+#endif
+
 };
 
 struct config_usb_cfg {
@@ -1444,14 +1461,142 @@ static void configfs_composite_unbind(struct usb_gadget *gadget)
 	set_gadget_data(gadget, NULL);
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+	char *buf)
+{
+	struct gadget_info *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!dev)
+	goto out;
+
+	cdev = &dev->cdev;
+
+	if (!cdev)
+	goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+	state = "CONFIGURED";
+	else if (dev->connected)
+	state = "CONNECTED";
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+
+static struct device_attribute *cfs_usb_attributes[] = {
+	&dev_attr_state,
+	NULL
+};
+
+static void cfs_uevent_work(struct work_struct *data)
+{
+	struct gadget_info *gi = container_of(data, struct gadget_info, work);
+	struct usb_composite_dev *cdev = &gi->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2] = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2] = { "USB_STATE=CONFIGURED", NULL };
+	/* 0-connected 1-configured 2-disconnected*/
+	bool status[3] = { false, false, false };
+	unsigned long flags;
+	bool uevent_sent = false;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+	status[1] = true;
+
+	if (gi->connected != gi->sw_connected) {
+	if (gi->connected)
+	status[0] = true;
+	else
+	status[2] = true;
+	gi->sw_connected = gi->connected;
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (status[0]) {
+	kobject_uevent_env(&usb_gadget_device->kobj,
+	KOBJ_CHANGE, connected);
+	pr_info("%s: sent uevent %s\n", __func__, connected[0]);
+	uevent_sent = true;
+	}
+
+	if (status[1]) {
+	kobject_uevent_env(&usb_gadget_device->kobj,
+	KOBJ_CHANGE, configured);
+	pr_info("%s: sent uevent %s\n", __func__, configured[0]);
+	uevent_sent = true;
+	}
+
+	if (status[2]) {
+	kobject_uevent_env(&usb_gadget_device->kobj,
+	KOBJ_CHANGE, disconnected);
+	pr_info("%s: sent uevent %s\n", __func__, disconnected[0]);
+	uevent_sent = true;
+	}
+
+	if (!uevent_sent) {
+	pr_info("%s: did not send uevent (%d %d %p)\n", __func__,
+	gi->connected, gi->sw_connected, cdev->config);
+	}
+}
+
+static int cfs_uevent_setup(struct usb_gadget *gadget,
+	const struct usb_ctrlrequest *c)
+{
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+	unsigned long flags;
+	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
+	int value = -EOPNOTSUPP;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (!gi->connected) {
+	gi->connected = 1;
+	schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	value = composite_setup(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+	cdev->config) {
+	schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+static void cfs_uevent_disconnect(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
+
+	gi->connected = 0;
+	schedule_work(&gi->work);
+	composite_disconnect(gadget);
+}
+#endif
+
 static const struct usb_gadget_driver configfs_driver_template = {
 	.bind           = configfs_composite_bind,
 	.unbind         = configfs_composite_unbind,
-
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	.setup = cfs_uevent_setup,
+	.reset = cfs_uevent_disconnect,
+	.disconnect = cfs_uevent_disconnect,
+#else
 	.setup          = composite_setup,
 	.reset          = composite_disconnect,
 	.disconnect     = composite_disconnect,
-
+#endif
 	.suspend	= composite_suspend,
 	.resume		= composite_resume,
 
@@ -1468,6 +1613,11 @@ static struct config_group *gadgets_make(
 {
 	struct gadget_info *gi;
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	int err;
+#endif
 	gi = kzalloc(sizeof(*gi), GFP_KERNEL);
 	if (!gi)
 		return ERR_PTR(-ENOMEM);
@@ -1507,8 +1657,25 @@ static struct config_group *gadgets_make(
 	gi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);
 	gi->composite.name = gi->composite.gadget_driver.function;
 
-	if (!gi->composite.gadget_driver.function)
+//	if (!gi->composite.gadget_driver.function)
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	INIT_WORK(&gi->work, cfs_uevent_work);
+	usb_gadget_device = device_create(usb_gadget_class, NULL,
+	MKDEV(0, 0), NULL, "egg0");
+	if (IS_ERR(usb_gadget_device))
 		goto err;
+	dev_set_drvdata(usb_gadget_device, gi);
+
+	attrs = cfs_usb_attributes;
+	while ((attr = *attrs++)) {
+	err = device_create_file(usb_gadget_device, attr);
+	if (err)
+	goto err1;
+	}
+#endif
+
+	if (!gi->composite.gadget_driver.function)
+	goto err1;
 
 #ifdef CONFIG_USB_OTG
 	gi->otg.bLength = sizeof(struct usb_otg_descriptor);
@@ -1519,13 +1686,30 @@ static struct config_group *gadgets_make(
 	config_group_init_type_name(&gi->group, name,
 				&gadget_root_type);
 	return &gi->group;
+err1:
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	attrs = cfs_usb_attributes;
+	while ((attr = *attrs++))
+	device_remove_file(usb_gadget_device, attr);
+	device_destroy(usb_gadget_device->class, usb_gadget_device->devt);
+
 err:
+#endif
 	kfree(gi);
 	return ERR_PTR(-ENOMEM);
 }
 
 static void gadgets_drop(struct config_group *group, struct config_item *item)
 {
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+
+	attrs = cfs_usb_attributes;
+	while ((attr = *attrs++))
+	device_remove_file(usb_gadget_device, attr);
+	device_destroy(usb_gadget_device->class, usb_gadget_device->devt);
+#endif
 	config_item_put(item);
 }
 
@@ -1564,6 +1748,11 @@ static int __init gadget_cfs_init(void)
 	config_group_init(&gadget_subsys.su_group);
 
 	ret = configfs_register_subsystem(&gadget_subsys);
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	usb_gadget_class = class_create(THIS_MODULE, "egg_usb");
+	if (IS_ERR(usb_gadget_class))
+	return PTR_ERR(usb_gadget_class);
+#endif
 	return ret;
 }
 module_init(gadget_cfs_init);
@@ -1571,5 +1760,9 @@ module_init(gadget_cfs_init);
 static void __exit gadget_cfs_exit(void)
 {
 	configfs_unregister_subsystem(&gadget_subsys);
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	if (!IS_ERR(usb_gadget_class))
+	class_destroy(usb_gadget_class);
+#endif
 }
 module_exit(gadget_cfs_exit);
-- 
1.9.1

