From 2aaaf9e30f94e32d5df80900526bfd08c52f82a7 Mon Sep 17 00:00:00 2001
From: Sudhakar Krishnan <sudhakar25@gmail.com>
Date: Sun, 15 Nov 2015 12:58:10 -0800
Subject: [PATCH] add i2c shared controller for axp288

---
 drivers/i2c/busses/Kconfig                  |  10 +++
 drivers/i2c/busses/Makefile                 |   1 +
 drivers/i2c/busses/i2c-designware-core.h    |  14 ++++
 drivers/i2c/busses/i2c-designware-platdrv.c |  78 ++++++++++++++++++++-
 drivers/i2c/busses/i2c-shared-controller.c  | 101 ++++++++++++++++++++++++++++
 5 files changed, 202 insertions(+), 2 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-shared-controller.c

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 2255af2..a78a89a 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -494,6 +494,16 @@ config I2C_DIGICOLOR
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-digicolor.
 
+config I2C_SHARED_CONTROLLER
+	tristate "Intel Baytrail PMIC shared I2C bus support"
+	depends on ACPI
+	select IOSF_MBI
+	select I2C_DESIGNWARE_CORE
+	help
+	  This driver enables shared access to the PMIC I2C bus on select Intel
+	  BayTrail platforms using the XPower AXP288 PMIC. This driver is
+	  required for host access to the PMIC on these platforms.
+
 config I2C_EFM32
 	tristate "EFM32 I2C controller"
 	depends on ARCH_EFM32 || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index cdf941d..2ccb428 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -45,6 +45,7 @@ i2c-designware-platform-objs := i2c-designware-platdrv.o
 i2c-designware-platform-$(CONFIG_I2C_DESIGNWARE_BAYTRAIL) += i2c-designware-baytrail.o
 obj-$(CONFIG_I2C_DESIGNWARE_PCI)	+= i2c-designware-pci.o
 i2c-designware-pci-objs := i2c-designware-pcidrv.o
+i2c-designware-platform-$(CONFIG_I2C_SHARED_CONTROLLER) += i2c-shared-controller.o
 obj-$(CONFIG_I2C_DIGICOLOR)	+= i2c-digicolor.o
 obj-$(CONFIG_I2C_EFM32)		+= i2c-efm32.o
 obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index 9630222..cd15bb3 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -61,6 +61,10 @@
  * @ss_lcnt: standard speed LCNT value
  * @fs_hcnt: fast speed HCNT value
  * @fs_lcnt: fast speed LCNT value
+ * @shared_host: if host must share access to adapter with other
+ * firmware/hardware units
+ * @acquire_ownership: function to acquire exclusive use of the controller
+ * @release_ownership: function to release exclusive use of the controller
  * @acquire_lock: function to acquire a hardware lock on the bus
  * @release_lock: function to release a hardware lock on the bus
  * @pm_runtime_disabled: true if pm runtime is disabled
@@ -104,6 +108,11 @@ struct dw_i2c_dev {
 	u16			ss_lcnt;
 	u16			fs_hcnt;
 	u16			fs_lcnt;
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+	int			shared_host;
+	int			(*acquire_ownership)(struct device *dev);
+	int			(*release_ownership)(struct device *dev);
+#endif
 	int			(*acquire_lock)(struct dw_i2c_dev *dev);
 	void			(*release_lock)(struct dw_i2c_dev *dev);
 	bool			pm_runtime_disabled;
@@ -126,6 +135,11 @@ extern void i2c_dw_clear_int(struct dw_i2c_dev *dev);
 extern void i2c_dw_disable_int(struct dw_i2c_dev *dev);
 extern u32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev);
 
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+extern int i2c_acquire_ownership(struct device *dev);
+extern int i2c_release_ownership(struct device *dev);
+#endif
+
 #if IS_ENABLED(CONFIG_I2C_DESIGNWARE_BAYTRAIL)
 extern int i2c_dw_eval_lock_support(struct dw_i2c_dev *dev);
 #else
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 3dd2de3..4267a98 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -50,6 +50,32 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 	return clk_get_rate(dev->clk)/1000;
 }
 
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+int i2c_shared_controller_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+	int num)
+{
+	struct dw_i2c_dev *dev = i2c_get_adapdata(adap);
+	int err;
+
+	if (dev->shared_host) {
+		err = dev->acquire_ownership(dev->dev);
+		if (!err) {
+			err = i2c_dw_xfer(adap, msgs, num);
+			dev->release_ownership(dev->dev);
+		} else
+			dev_WARN(dev->dev, "couldnt acquire ownership\n");
+
+		return err;
+	} else
+		return i2c_dw_xfer(adap, msgs, num);
+}
+
+static struct i2c_algorithm i2c_sc_algo = {
+	.master_xfer	= i2c_shared_controller_xfer,
+	.functionality	= i2c_dw_func,
+};
+#endif
+
 #ifdef CONFIG_ACPI
 static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
@@ -79,6 +105,13 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 	const struct acpi_device_id *id;
 
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
+	acpi_status status;
+	unsigned long long shared_host = 0;
+
+	if (!handle)
+ 		return -ENODEV;
+	
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
 	dev->rx_fifo_depth = 32;
@@ -91,6 +124,25 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
 			   &dev->sda_hold_time);
 
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+	/*
+	 * For Intel SOC's determine if i2c bus must be shared with PUNIT
+	 * hardware
+	 */
+	status = acpi_evaluate_integer(handle, "_SEM", NULL, &shared_host);
+
+	if (ACPI_SUCCESS(status))
+		dev_info(&pdev->dev, "_SEM=%ld\n", (long)shared_host);
+
+	if (shared_host != 0) {
+		dev_info(&pdev->dev,
+			"Host shares controller with other hardware\n");
+		dev->shared_host = 1;
+		dev->acquire_ownership = i2c_acquire_ownership;
+		dev->release_ownership = i2c_release_ownership;
+	}
+#endif /* CONFIG_I2C_SHARED_CONTROLLER */
+
 	/*
 	 * Provide a way for Designware I2C host controllers that are not
 	 * based on Intel LPSS to specify their input clock frequency via
@@ -253,6 +305,25 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
 
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+	if (dev->shared_host)
+		adap->algo = &i2c_sc_algo;
+
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(&pdev->dev, "failure adding adapter\n");
+		return r;
+	}
+
+	if (dev->shared_host)
+		pm_runtime_forbid(&pdev->dev);
+	else {
+		pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+		pm_runtime_use_autosuspend(&pdev->dev);
+		pm_runtime_set_active(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
+#else
 	r = i2c_add_numbered_adapter(adap);
 	if (r) {
 		dev_err(&pdev->dev, "failure adding adapter\n");
@@ -267,7 +338,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		pm_runtime_set_active(&pdev->dev);
 		pm_runtime_enable(&pdev->dev);
 	}
-
+#endif
 	return 0;
 }
 
@@ -336,7 +407,10 @@ static int dw_i2c_resume(struct device *dev)
 
 	if (!i_dev->pm_runtime_disabled)
 		i2c_dw_init(i_dev);
-
+#if IS_ENABLED(CONFIG_I2C_SHARED_CONTROLLER)
+	if (!i_dev->shared_host)
+		i2c_dw_init(i_dev);
+#endif
 	return 0;
 }
 
diff --git a/drivers/i2c/busses/i2c-shared-controller.c b/drivers/i2c/busses/i2c-shared-controller.c
new file mode 100644
index 0000000..b9119a0
--- /dev/null
+++ b/drivers/i2c/busses/i2c-shared-controller.c
@@ -0,0 +1,101 @@
+/*
+ * Intel SOC I2C bus sharing semphore implementation
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/iosf_mbi.h>
+
+#define PUNIT_SEMAPHORE 0x7
+static unsigned long start_time, end_time;
+
+static int get_sem(struct device *dev, u32 *sem)
+{
+	u32 reg_val;
+	int ret;
+
+	ret = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ, PUNIT_SEMAPHORE,
+			    &reg_val);
+	if (ret) {
+		dev_WARN(dev, "iosf failed to read punit semaphore\n");
+		return ret;
+	}
+
+	*sem = reg_val & 0x1;
+
+	return 0;
+}
+
+static void reset_semaphore(struct device *dev)
+{
+	u32 data;
+
+	if (iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,
+				PUNIT_SEMAPHORE, &data)) {
+		dev_err(dev, "iosf failed to reset punit semaphore\n");
+		return;
+	}
+
+	data = data & 0xfffffffe;
+	if (iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,
+				 PUNIT_SEMAPHORE, data))
+		dev_err(dev, "iosf failed to reset punit semaphore\n");
+}
+
+int i2c_acquire_ownership(struct device *dev)
+{
+	u32 sem = 0;
+	int ret;
+	int timeout = 100;
+
+	/* host driver writes 0x2 to side band semaphore register */
+	ret = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,
+				 PUNIT_SEMAPHORE, 0x2);
+	if (ret) {
+		dev_WARN(dev, "iosf failed to request punit semaphore\n");
+		return ret;
+	}
+
+	/* host driver waits for bit 0 to be set in semaphore register */
+	while (1) {
+		ret = get_sem(dev, &sem);
+		if (!ret && sem) {
+			start_time = jiffies;
+			dev_dbg(dev, "punit semaphore acquired after %d attempts\n",
+				101 - timeout);
+			return 0;
+		}
+
+		usleep_range(1000, 2000);
+		timeout--;
+		if (timeout <= 0) {
+			dev_err(dev, "punit semaphore timed out, resetting\n");
+			reset_semaphore(dev);
+			iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,
+				PUNIT_SEMAPHORE, &sem);
+			dev_err(dev, "PUNIT SEM: %d\n", sem);
+			WARN_ON(1);
+			return -ETIMEDOUT;
+		}
+
+	}
+}
+
+int i2c_release_ownership(struct device *dev)
+{
+	reset_semaphore(dev);
+	end_time = jiffies;
+	dev_dbg(dev, "punit semaphore release call finish, held for %ldms\n",
+		(end_time - start_time) * 1000 / HZ);
+	return 0;
+}
-- 
1.9.1

