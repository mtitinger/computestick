From c79a95e11ca93ac1817ae6b85c6453f21b0f7ca7 Mon Sep 17 00:00:00 2001
From: Sudhakar Krishnan <sudhakar25@gmail.com>
Date: Tue, 10 Nov 2015 22:32:26 -0800
Subject: [PATCH] add axp2xx fix

---
 drivers/mfd/axp20x.c              | 100 ++++++++++++++++++++++++++++++++++++++
 drivers/power/axp288_charger.c    |   2 +
 drivers/power/axp288_fuel_gauge.c |  58 ++--------------------
 include/linux/mfd/axp20x.h        |   4 ++
 4 files changed, 109 insertions(+), 55 deletions(-)

diff --git a/drivers/mfd/axp20x.c b/drivers/mfd/axp20x.c
index 6aa1667..47f6da2 100644
--- a/drivers/mfd/axp20x.c
+++ b/drivers/mfd/axp20x.c
@@ -32,6 +32,7 @@
 static const char * const axp20x_model_names[] = {
 	"AXP202",
 	"AXP209",
+	"AXP221",
 	"AXP288",
 };
 
@@ -54,6 +55,25 @@ static const struct regmap_access_table axp20x_volatile_table = {
 	.n_yes_ranges	= ARRAY_SIZE(axp20x_volatile_ranges),
 };
 
+static const struct regmap_range axp22x_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP22X_BATLOW_THRES1),
+};
+
+static const struct regmap_range axp22x_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
+};
+
+static const struct regmap_access_table axp22x_writeable_table = {
+	.yes_ranges	= axp22x_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp22x_writeable_ranges),
+};
+
+static const struct regmap_access_table axp22x_volatile_table = {
+	.yes_ranges	= axp22x_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp22x_volatile_ranges),
+};
+
 static const struct regmap_range axp288_writeable_ranges[] = {
 	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ6_STATE),
 	regmap_reg_range(AXP20X_DCDC_MODE, AXP288_FG_TUNE5),
@@ -87,6 +107,20 @@ static struct resource axp20x_pek_resources[] = {
 	},
 };
 
+static struct resource axp22x_pek_resources[] = {
+	{
+		.name   = "PEK_DBR",
+		.start  = AXP22X_IRQ_PEK_RIS_EDGE,
+		.end    = AXP22X_IRQ_PEK_RIS_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	}, {
+		.name   = "PEK_DBF",
+		.start  = AXP22X_IRQ_PEK_FAL_EDGE,
+		.end    = AXP22X_IRQ_PEK_FAL_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
 static struct resource axp288_fuel_gauge_resources[] = {
 	{
 		.start = AXP288_IRQ_QWBTU,
@@ -129,6 +163,15 @@ static const struct regmap_config axp20x_regmap_config = {
 	.cache_type	= REGCACHE_RBTREE,
 };
 
+static const struct regmap_config axp22x_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp22x_writeable_table,
+	.volatile_table	= &axp22x_volatile_table,
+	.max_register	= AXP22X_BATLOW_THRES1,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
 static const struct regmap_config axp288_regmap_config = {
 	.reg_bits	= 8,
 	.val_bits	= 8,
@@ -181,6 +224,34 @@ static const struct regmap_irq axp20x_regmap_irqs[] = {
 	INIT_REGMAP_IRQ(AXP20X, GPIO0_INPUT,		4, 0),
 };
 
+static const struct regmap_irq axp22x_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP22X, ACIN_OVER_V,		0, 7),
+	INIT_REGMAP_IRQ(AXP22X, ACIN_PLUGIN,		0, 6),
+	INIT_REGMAP_IRQ(AXP22X, ACIN_REMOVAL,	        0, 5),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_OVER_V,		0, 4),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_PLUGIN,		0, 3),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_REMOVAL,	        0, 2),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_V_LOW,		0, 1),
+	INIT_REGMAP_IRQ(AXP22X, BATT_PLUGIN,		1, 7),
+	INIT_REGMAP_IRQ(AXP22X, BATT_REMOVAL,	        1, 6),
+	INIT_REGMAP_IRQ(AXP22X, BATT_ENT_ACT_MODE,	1, 5),
+	INIT_REGMAP_IRQ(AXP22X, BATT_EXIT_ACT_MODE,	1, 4),
+	INIT_REGMAP_IRQ(AXP22X, CHARG,		        1, 3),
+	INIT_REGMAP_IRQ(AXP22X, CHARG_DONE,		1, 2),
+	INIT_REGMAP_IRQ(AXP22X, BATT_TEMP_HIGH,	        1, 1),
+	INIT_REGMAP_IRQ(AXP22X, BATT_TEMP_LOW,	        1, 0),
+	INIT_REGMAP_IRQ(AXP22X, DIE_TEMP_HIGH,	        2, 7),
+	INIT_REGMAP_IRQ(AXP22X, PEK_SHORT,		2, 1),
+	INIT_REGMAP_IRQ(AXP22X, PEK_LONG,		2, 0),
+	INIT_REGMAP_IRQ(AXP22X, LOW_PWR_LVL1,	        3, 1),
+	INIT_REGMAP_IRQ(AXP22X, LOW_PWR_LVL2,	        3, 0),
+	INIT_REGMAP_IRQ(AXP22X, TIMER,		        4, 7),
+	INIT_REGMAP_IRQ(AXP22X, PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(AXP22X, PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(AXP22X, GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(AXP22X, GPIO0_INPUT,		4, 0),
+};
+
 /* some IRQs are compatible with axp20x models */
 static const struct regmap_irq axp288_regmap_irqs[] = {
 	INIT_REGMAP_IRQ(AXP288, VBUS_FALL,              0, 2),
@@ -224,6 +295,7 @@ static const struct regmap_irq axp288_regmap_irqs[] = {
 static const struct of_device_id axp20x_of_match[] = {
 	{ .compatible = "x-powers,axp202", .data = (void *) AXP202_ID },
 	{ .compatible = "x-powers,axp209", .data = (void *) AXP209_ID },
+	{ .compatible = "x-powers,axp221", .data = (void *) AXP221_ID },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, axp20x_of_match);
@@ -258,6 +330,18 @@ static const struct regmap_irq_chip axp20x_regmap_irq_chip = {
 
 };
 
+static const struct regmap_irq_chip axp22x_regmap_irq_chip = {
+	.name			= "axp22x_irq_chip",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp22x_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp22x_regmap_irqs),
+	.num_regs		= 5,
+};
+
 static const struct regmap_irq_chip axp288_regmap_irq_chip = {
 	.name			= "axp288_irq_chip",
 	.status_base		= AXP20X_IRQ1_STATE,
@@ -281,6 +365,16 @@ static struct mfd_cell axp20x_cells[] = {
 	},
 };
 
+static struct mfd_cell axp22x_cells[] = {
+	{
+		.name			= "axp20x-pek",
+		.num_resources		= ARRAY_SIZE(axp22x_pek_resources),
+		.resources		= axp22x_pek_resources,
+	}, {
+		.name			= "axp20x-regulator",
+	},
+};
+
 static struct resource axp288_adc_resources[] = {
 	{
 		.name  = "GPADC",
@@ -626,6 +720,12 @@ static int axp20x_match_device(struct axp20x_dev *axp20x, struct device *dev)
 		axp20x->regmap_cfg = &axp20x_regmap_config;
 		axp20x->regmap_irq_chip = &axp20x_regmap_irq_chip;
 		break;
+	case AXP221_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp22x_cells);
+		axp20x->cells = axp22x_cells;
+		axp20x->regmap_cfg = &axp22x_regmap_config;
+		axp20x->regmap_irq_chip = &axp22x_regmap_irq_chip;
+		break;
 	case AXP288_ID:
 		axp20x->cells = axp288_cells;
 		axp20x->nr_cells = ARRAY_SIZE(axp288_cells);
diff --git a/drivers/power/axp288_charger.c b/drivers/power/axp288_charger.c
index 5fa477f..d64ef3d 100644
--- a/drivers/power/axp288_charger.c
+++ b/drivers/power/axp288_charger.c
@@ -939,3 +939,5 @@ static struct platform_driver axp288_charger_driver = {
 module_platform_driver(axp288_charger_driver);
 
 MODULE_AUTHOR("Ramakrishna Pallala <ramakrishna.pallala@intel.com>");
+MODULE_DESCRIPTION("X-power AXP288 Charger Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/axp288_fuel_gauge.c b/drivers/power/axp288_fuel_gauge.c
index 0a562ef..50c0110 100644
--- a/drivers/power/axp288_fuel_gauge.c
+++ b/drivers/power/axp288_fuel_gauge.c
@@ -157,37 +157,12 @@ static enum power_supply_property fuel_gauge_props[] = {
 	POWER_SUPPLY_PROP_MODEL_NAME,
 };
 
-#define PLATFORM_DATA
-
-#ifdef PLATFORM_DATA
-
-static struct axp20x_fg_pdata pdata;
-static void *get_platform_data(void)
-{
-
-	pdata.design_cap = 4980;
-	pdata.min_volt = 3400;
-	pdata.max_volt = 4350;
-	pdata.max_temp = 45;
-	pdata.min_temp = 0;
-
-    return &pdata;
-}
-
-void *axp288_fg_data(void *info)
-{
-	return get_platform_data();
-}
-#endif
-
 static int fuel_gauge_reg_readb(struct axp288_fg_info *info, int reg)
 {
 	int ret, i;
 	unsigned int val;
 
 	for (i = 0; i < NR_RETRY_CNT; i++) {
-		ret = regmap_read(info->regmap, 0xB9, &val);
-		printk("axp288_fuel_gauge: \n ret:%d val:%d", ret, val);
 		ret = regmap_read(info->regmap, reg, &val);
 		if (ret == -EBUSY)
 			continue;
@@ -443,7 +418,6 @@ current_read_fail:
 	return ret;
 }
 
-#ifdef PLATFORM_DATA
 static int temp_to_adc(struct axp288_fg_info *info, int tval)
 {
 	int rntc = 0, i, ret, adc_val;
@@ -485,7 +459,6 @@ static int temp_to_adc(struct axp288_fg_info *info, int tval)
 
 	return adc_val;
 }
-#endif
 
 static int adc_to_temp(struct axp288_fg_info *info, int adc_val)
 {
@@ -620,7 +593,7 @@ static int fuel_gauge_get_property(struct power_supply *ps,
 
 	mutex_lock(&info->lock);
 	switch (prop) {
-		/*	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_STATUS:
 		fuel_gauge_get_status(info);
 		val->intval = info->status;
 		break;
@@ -655,12 +628,8 @@ static int fuel_gauge_get_property(struct power_supply *ps,
 		else
 			val->intval = 0;
 		break;
-		*/
 	case POWER_SUPPLY_PROP_CAPACITY:
-		//ret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);
-		ret = fuel_gauge_reg_readb(info, 0xB9);
-		dev_info(&info->pdev->dev,
-				"reading capacity\n");
+		ret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);
 		if (ret < 0)
 			goto fuel_gauge_read_err;
 
@@ -668,10 +637,7 @@ static int fuel_gauge_get_property(struct power_supply *ps,
 			dev_err(&info->pdev->dev,
 				"capacity measurement not valid\n");
 		val->intval = (ret & FG_REP_CAP_VAL_MASK);
-		dev_info(&info->pdev->dev,
-				 "current capacity is %d", val->intval);
 		break;
-		/*
 	case POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:
 		ret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);
 		if (ret < 0)
@@ -731,7 +697,6 @@ static int fuel_gauge_get_property(struct power_supply *ps,
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = info->pdata->battid;
 		break;
-		*/
 	default:
 		mutex_unlock(&info->lock);
 		return -EINVAL;
@@ -1127,25 +1092,8 @@ static int axp288_fuel_gauge_probe(struct platform_device *pdev)
 	info->regmap_irqc = axp20x->regmap_irqc;
 	info->status = POWER_SUPPLY_STATUS_UNKNOWN;
 	info->pdata = pdev->dev.platform_data;
-#ifdef PLATFORM_DATA
-	info->pdata = axp288_fg_data(NULL);
-#else
-	info->pdata = pdev->dev.platform_data;
-//	if (!info->pdata)
-#endif
-#ifdef PLATFORM_DATA
-	if (!info->pdata){
-		printk("platform device name: %s\n", pdev->name);
-		printk("platform device id: %d\n", pdev->id);
-		if (pdev->dev.parent->platform_data != NULL)
-			printk("we have pdev->dev.parent->platform_data here\n");
-		printk("device parent name: %s\n", pdev->dev.parent->init_name);
-		if (pdev->dev.parent != NULL)
-			printk("we have pdev->dev.parent here\n");
-		printk("no platform data\n");
+	if (!info->pdata)
 		return -ENODEV;
-	}
-#endif
 
 	platform_set_drvdata(pdev, info);
 
diff --git a/include/linux/mfd/axp20x.h b/include/linux/mfd/axp20x.h
index c2aa853..46b3fa4 100644
--- a/include/linux/mfd/axp20x.h
+++ b/include/linux/mfd/axp20x.h
@@ -366,6 +366,10 @@ struct axp20x_chrg_pdata {
 	int max_cv;
 	int def_cc;
 	int def_cv;
+    int def_ilim;
+    int def_iterm;
+    int def_max_temp;
+    int def_min_temp;
 };
 
 struct axp288_extcon_pdata {
-- 
1.9.1

